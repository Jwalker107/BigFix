# Example of building & sending one or more SingleAction commands to the BigFix Server
# Run a query to retrieve one or more source fixlets, build SingleAction XML for each, and post the action to the server
# Target computers are assigned ahead of time, and a MIME field is included in the action.
#
import requests

# Disable SSL warnings - urllib3 is used internally by 'requests'
from urllib3.exceptions import InsecureRequestWarning
from urllib3 import disable_warnings as urllib3_disable_warnings

urllib3_disable_warnings(InsecureRequestWarning)

from xml.etree import ElementTree
from xml.dom import minidom

certverify = False
server_url = "https://my-root-server:52311"
username = "my-operator-account"
password = "my-password"


def pretty_xml(input: str, xml_declaration=True, encoding="UTF-8") -> str:
    """Pretty print an XML string or ElementTree.Element object."""
    if type(input) is str:
        myXML = input
    elif type(input) is ElementTree.Element:
        myXML = ElementTree.tostring(
            input, encoding=encoding, method="xml", xml_declaration=xml_declaration
        ).decode()
    else:
        raise ValueError("Input must be a string or an ElementTree.Element")

    # Convert the ElementTree to a string and parse it with minidom for pretty printing
    dom = minidom.parseString(myXML)
    return dom.toprettyxml(encoding=encoding, indent="  ").decode()


def build_xml_SingleAction(action_dict: dict):
    # Builds the XML to post a SingleAction from a dictionary of action parameters

    # Just an example of some simple validation we can do.  Better to compare the finished XML to the schema, but this is a quick check
    for required_key in [
        "action_script",
        "targets",
        "target_type",
        "relevance",
        "action_script",
    ]:
        # each required_key must be present, and not empty (None and "" evaluate as False)
        if required_key not in action_dict or not bool(action_dict[required_key]):
            raise ValueError(
                f"ERROR in build_xml_SingleAction: Missing required key '{required_key}' in action_dict"
            )

    # Create a BES root element and set the XML namespace attributes
    root = ElementTree.Element("BES")
    # Create or update elements as needed
    root.set("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
    root.set("xsi:noNamespaceSchemaLocation", "BES.xsd")

    # Example of appending a comment to the root element
    root.append(ElementTree.Comment("XML Generated by build_xml_SingleAction"))

    # One method to create a child element - build a new element and append it to an existing element

    element = ElementTree.Element("SingleAction")
    root.append(element)

    # Another method to create a child element is to use ElementTree.SubElement, which will create new sub-elements as needed
    single_action = root.find("SingleAction")
    title = ElementTree.SubElement(single_action, "Title")
    title.text = action_dict.get("title", "Default Action Title")

    relevance = ElementTree.SubElement(single_action, "Relevance")
    relevance.text = action_dict.get("relevance", "true")

    action_script = ElementTree.SubElement(single_action, "ActionScript")
    action_script.text = action_dict.get("action_script", "//default action script")

    success_criteria = ElementTree.SubElement(single_action, "SuccessCriteria")
    success_criteria.text = action_dict.get("success_criteria", "RunToCompletion")

    # We can also walk directly down through new nodes = here the first SubElement is of parent, and the second is a subelement of newnode
    target_node = ElementTree.SubElement(single_action, "Target")

    ## Target may be a relevance statement, or a list of Computer Names or Computer IDs
    if isinstance(action_dict.get("targets"), list):
        for target in action_dict.get("targets"):
            newtarget = ElementTree.SubElement(
                target_node, action_dict.get("target_type", "ComputerId")
            )
            newtarget.text = str(target)
    else:
        newtarget = ElementTree.SubElement(
            target_node, action_dict.get("target_type", "ComputerId")
        )
        newtarget.text = action_dict.get("targets")

    # If this is from a Source Fixlet, add those elements to the XML DOM
    if (
        bool(action_dict.get("source_fixlet_id", None))
        and bool(action_dict.get("source_fixlet_site", None))
        and bool(action_dict.get("source_fixlet_site_type", None))
        and bool(action_dict.get("source_action_id", None))
    ):
        # All fields required for a Source Fixlet are preset
        source_fixlet = ElementTree.SubElement(single_action, "SourceFixlet")
        source_site_type = ElementTree.SubElement(
            source_fixlet, action_dict.get("source_fixlet_site_type")
        )  # SiteType could be "SiteName" or "SiteID"
        source_site_type.text = action_dict.get("source_fixlet_site")
        source_fixlet_id = ElementTree.SubElement(source_fixlet, "FixletID")
        source_fixlet_id.text = action_dict.get("source_fixlet_id")
        source_action = ElementTree.SubElement(source_fixlet, "Action")
        source_action.text = action_dict.get("source_action_id", "Action1")

    # If there are MIME fields, add them to the XML DOM
    for mimefield in action_dict.get("mime_fields", []):
        mime_field_node = ElementTree.SubElement(single_action, "MIMEField")

        for name, value in mimefield.items():
            name_node = ElementTree.SubElement(mime_field_node, "Name")
            name_node.text = name
            value_node = ElementTree.SubElement(mime_field_node, "Value")
            value_node.text = str(value)

    return ElementTree.tostring(root, encoding="UTF-8", method="xml").decode()


action_dict = {
    "targets": ["BES-Root"],
    "target_type": "ComputerName",
    "mime_fields": [{"my-custom-mime-field": "1"}],
}

# example values
# action_dict = {
#     "action_script": "//hello world",
#     "targets": ["BES-Root"],
#     "target_type": "ComputerName",
#     "relevance": "false",
#     "title": "Test Action",
#     "success_criteria": "RunToCompletion",
#     "mime_fields": [],
# }

# action_dict["source_fixlet_id"] = 572
# action_dict["source_fixlet_site"] = "Enterprise Security"
# action_dict["source_fixlet_site_type"] = "Sitename"
# action_dict["source_action_id"] = "Action1"

# Run a query to retrieve the source fixlet
# Must return an array of ['id','name','contentid','relevance','actionscript','sitetype','sitevalue','successcriteria']

query = '(id of it as string, name of it, content id of default action of it , relevance of it, script of default action of it, "Sitename", name of site of it, (if success on original relevance of default action of it then "OriginalRelevance" else "RunToCompletion")) of fixlet whose (id of it = 572) of all bes sites whose (name of it = "Enterprise Security")'
response = requests.post(
    url=f"{server_url}/api/query",
    data={"relevance": query, "output": "json"},
    headers=None,
    auth=(username, password),
    verify=certverify,
)

if not response.ok:
    raise ValueError(
        f"Error encountered when sending query to {server_url}/api/query: HTTP {response.status_code} {response.reason}"
    )
if "error" in response.json():
    raise ValueError(
        f"Error encountered when evaluating relevance query: {response.json()['error']}"
    )

if not response.json()["result"]:
    raise ValueError(f"No results returned from query: {query}")

if len(response.json()["result"]) == 0:
    raise ValueError(f"Query returned no results: {query}")

# If we want to send multiple actions, removed this check and loop through the results
# if len(response.json()["result"]) > 1:
#     raise ValueError(f"Query returned multiple results results: {query}")

for fixlet in response.json()["result"]:
    action_dict["source_fixlet_id"] = fixlet[0]
    action_dict["title"] = f"Scripted Action from {fixlet[1]}"
    action_dict["source_action_id"] = fixlet[2]
    action_dict["relevance"] = fixlet[3]
    action_dict["action_script"] = fixlet[4]
    action_dict["source_fixlet_site_type"] = fixlet[5]
    action_dict["source_fixlet_site"] = fixlet[6]
    action_dict["success_criteria"] = fixlet[7]
    myXML = build_xml_SingleAction(action_dict)
    print(pretty_xml(myXML))

    try:
        response = requests.request(
            method="POST",
            url=f"{server_url}/api/actions",
            data=myXML,
            headers=None,
            verify=certverify,
            auth=(username, password),
            params=None,
        )

    except Exception as e:
        print("Error encountered connecting to the API: " + str(e))
    else:
        if not response.ok:
            print("HTTP " + str(response.status_code) + " " + response.reason)
        else:
            print("Action sent:")
            print(response.text)
